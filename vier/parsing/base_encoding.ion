import std

struct BaseEncoding {
    base64: HParser*;
}

func base_encoding_rfc4648(abnf: ABNF_RFC5234*, allocator: Allocator*): BaseEncoding {
    allocator_data := hallocator_bridge_data(allocator);
    a := hallocator_bridge(&allocator_data);

    rules: BaseEncoding;
    plus := h_ch__m(a, '+');
    slash := h_ch__m(a, '/');
    equals := h_ch__m(a, '=');
    bsfdig := h_choice__m(a, abnf.ALPHA, abnf.DIGIT, plus, slash, 0);
    bsfdig_4bit := h_in__m(a, (:uint8*)"AEIMQUYcgkosw048", 16);
    bsfdig_2bit := h_in__m(a, (:uint8*)"AQgw", 4);
    base64_3 := h_repeat_n__m(a, bsfdig, 4);
    base64_2 := h_sequence__m(a, bsfdig, bsfdig, bsfdig_4bit, equals, 0);
    base64_1 := h_sequence__m(a, bsfdig, bsfdig_2bit, equals, equals, 0);
    rules.base64 = h_sequence__m(a, h_many__m(a, base64_3), h_optional__m(a, h_choice__m(a, base64_2, base64_1, 0)), 0);

    rules.base64 = h_action__m(a, rules.base64, base64_action, 0);

    return rules;
}

func test_base_encoding() {
    arena := std.arena_allocator(0, 0);
    memdata := hallocator_bridge_data(&arena.base);
    mem := hallocator_bridge(&memdata);

    abnf := abnf_rfc5234(&arena.base);
    rules := base_encoding_rfc4648(&abnf, &arena.base);
    inputs: char*[] = {
            "", "Zg==", "Zm8=", "Zm9v", "Zm9vYg==", "Zm9vYmE=", "Zm9vYmFy",
    };
    outputs: char*[] = {
            "", "f", "fo", "foo", "foob", "fooba", "foobar",
    };
    num_inputs := sizeof(inputs) / sizeof(inputs[0]);
    for (i:=0; i < num_inputs; i++) {
        input := inputs[i];
        r := h_parse__m(mem, rules.base64, (:uint8*)input, libc.strlen(input));
        #assert(r.ast.token_type == TT_BYTES);
        output := outputs[i];
        #assert(libc.strlen(output) == r.ast.bytes.len);
        for (ci:=0; ci < r.ast.bytes.len && output[ci]; ci++) {
            #assert(r.ast.bytes.token[ci] == output[ci]);
        }
    }
    std.arena_free(&arena);
}

func base64_action(p: HParseResult const*, user_data: void*): HParsedToken* {
    #assert(p.ast.token_type == TT_SEQUENCE);
    #assert(p.ast.seq.used == 2);

    b64_3 := p.ast.seq.elements[0];
    #assert(b64_3.token_type == TT_SEQUENCE);


    bytes_size := 4 * b64_3.seq.used + 3 /* max size necessary */;
    bytes: uint8 *const = h_arena_malloc(p.arena, bytes_size);
    bytes_end := bytes + bytes_size;
    bytes_last := bytes;

    // Concatenate base64_3 blocks:
    for (block_index:=0; block_index < b64_3.seq.used; block_index++) {
        block := b64_3.seq.elements[block_index];
        #assert(block.token_type == TT_SEQUENCE);
        #assert(block.seq.used == 4);
        for (bytei:=0; bytei < block.seq.used; bytei++) {
            e := block.seq.elements[bytei];
            #assert(e.token_type == TT_UINT);
            *bytes_last++ = e.uint;
            #assert(bytes_last <= bytes_end);
        }
    }
    // Concatenate b64 end block (_2 or _1) where the '=' sentinel may indicate a stop
    b64_end := p.ast.seq.elements[1];
    if (b64_end.token_type == TT_SEQUENCE) {
        digits := b64_end.seq.elements;
        count := (digits[2].uint == '=') ? 2 : 3;
        for (bytei:=0; bytei < count; bytei++) {
            e := digits[bytei];
            #assert(e.token_type == TT_UINT);
            *bytes_last++ = e.uint;
            #assert(bytes_last <= bytes_end);
        }
    }
    bytes_last = base64_pipeline(bytes, bytes_last);
    return h_make_bytes(p.arena, bytes, bytes_last - bytes);
}

// encoded digits in [first, last) are turned into bytes [first, return_value)
func base64_pipeline(first: uint8*, last: uint8*): uint8* {
    bsf_decode_inplace(first, last); // after which [first,last) contains sextets
    return gather_8from6bits(first, last, first);
}

func min_uint8(a: uint8, b: uint8): uint8 {
    return a < b ? a : b;
}

func bits_uint8(x: int, start: int, num_bits: int): uint8 {
    return uint8((x >> start) & ((1<<num_bits) - 1));
}

func gather_8from6bits(f: uint8*, l: uint8*, dst: uint8*): uint8* {
    num_available_source_bits := 0;
    s: uint8;
    num_writeable_dest_bits := 8;
    d: uint8;

    num := l - f;
    num_quads := num / 4;
    while (num_quads--) {
        dst[0] = (bits_uint8(f[0], 0, 6)<<2) | (bits_uint8(f[1], 4, 2));
        dst[1] = (bits_uint8(f[1], 0, 4)<<4) | (bits_uint8(f[2], 2, 4));
        dst[2] = (bits_uint8(f[2], 0, 2)<<6) | (bits_uint8(f[3], 0, 6));
        f += 4;
        dst += 3;
    }

    num = l - f;
    num_triples := num / 3;
    while (num_triples--) {
        dst[0] = (bits_uint8(f[0], 0, 6) << 2) | (bits_uint8(f[1], 4, 2));
        dst[1] = (bits_uint8(f[1], 0, 4) << 4) | (bits_uint8(f[2], 2, 4));
        f += 3;
        dst += 2;
    }

    num = l - f;
    num_pairs := num / 2;
    while (num_pairs--) {
        dst[0] = (bits_uint8(f[0], 0, 6) << 2) | (bits_uint8(f[1], 4, 2));
        f += 2;
        dst += 1;
    }

    num = l - f;
    while (num--) {
        dst[0] = bits_uint8(f[0], 0, 6) << 2;
        f++;
        dst++;
    }

    return dst;
}

func bsf_decode_inplace(f: uint8*, l: uint8*) {
    while (f != l) {
        x:= *f;
        y: uint8;
        switch(x) {
        case 'A'...'Z': y = x - 'A';
        case 'a'...'z': y = x - 'a' + 26;
        case '0'...'9': y = x - '0' + 52;
        case '+': y = 62;
        case '/': y = 63;
        default: #assert(0); // invalid input
        }
        *f++ = y;
    }
}
